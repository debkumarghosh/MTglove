using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using UnityEngine;

public class CubeController : MonoBehaviour
{
    public GameObject cube;  // Assign your cube GameObject in the Unity Inspector
    private TcpListener tcpListener;
    private Thread tcpListenerThread;
    public int port = 8080;

    private void Start()
    {
        // Start the TCP listener on a separate thread
        tcpListenerThread = new Thread(ListenForIncomingConnections);
        tcpListenerThread.IsBackground = true;
        tcpListenerThread.Start();
    }

    private void ListenForIncomingConnections()
    {
        try
        {
            // Create a TCP listener and start it
            tcpListener = new TcpListener(IPAddress.Any, port);
            tcpListener.Start();
            Debug.Log("Server is listening on port " + port);

            // Accept incoming connections in a loop
            while (true)
            {
                using (TcpClient client = tcpListener.AcceptTcpClient())
                using (NetworkStream stream = client.GetStream())
                {
                    Debug.Log("Connected to ESP32");

                    // Buffer for incoming data
                    byte[] buffer = new byte[1024];
                    int bytesRead;

                    // Read data until client disconnects
                    while ((bytesRead = stream.Read(buffer, 0, buffer.Length)) != 0)
                    {
                        // Convert received data to string
                        string receivedMessage = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                        Debug.Log("Received from ESP32: " + receivedMessage);

                        // Process data and update the cube
                        ProcessReceivedData(receivedMessage);
                    }
                }
            }
        }
        catch (SocketException e)
        {
            Debug.LogError("SocketException: " + e);
        }
        finally
        {
            tcpListener.Stop();
        }
    }

    private void ProcessReceivedData(string data)
    {
        // Split the data into components
        string[] values = data.Split(',');

        if (values.Length == 6)
        {
            try
            {
                // Parse accelerometer and gyroscope data
                float ax = float.Parse(values[0]);
                float ay = float.Parse(values[1]);
                float az = float.Parse(values[2]);
                float gx = float.Parse(values[3]);
                float gy = float.Parse(values[4]);
                float gz = float.Parse(values[5]);

                // Map the gyroscope data to cube rotation
                Vector3 rotation = new Vector3(gx / 100.0f, gy / 100.0f, gz / 100.0f); // Adjust scaling as needed
                cube.transform.Rotate(rotation);

                // Optionally, you can also use accelerometer data to affect cube position if desired
                Vector3 position = new Vector3(ax / 1000.0f, ay / 1000.0f, az / 1000.0f); // Adjust scaling as needed
                cube.transform.position = position;

            }
            catch (FormatException e)
            {
                Debug.LogError("Data parsing error: " + e.Message);
            }
        }
    }

    private void OnApplicationQuit()
    {
        // Stop the listener thread when the application is closed
        tcpListener?.Stop();
        tcpListenerThread?.Abort();
    }
}
